# Generator函数

## 基本概念

1. Generator函数特征：
   1. function关键字和函数名之间有个星号(*)，该星号并未规定特定位置，一般认为紧跟`function*`
   2. 函数体内部使用yield表达式，定义不同的内部状态
2. Generator函数的执行：
   1. 调用Generator函数会返回一个指向该函数内部指针的对象（即遍历器对象：可进行循环遍历），该函数并不执行
   2. 之后使用next()方法来获取下一个yield表达式的值的对象，当最终结果为`{value: undefined, done: true}`时，表示遍历结束，再次调用，将返回同样的结果
3. yield表达式：🍅
   1. 遍历器对象，遇到yield之后，就暂停后面的操作，并将yield表达式的值，赋给返回对象的value属性；若yield后面为空，则value属性为undefined
   2. 当调用next方法一直未遇到yield表达式，则运行到函数结尾，并将return的值作为value属性值；无return语句，则value属性值为undefined
   3. yield表达式后面的内容，只有当调用next方法时才会被执行，相当于提供了手动惰性求值的方法
   4. 当generator函数内无yield语句时，相当于单纯的暂停函数，调用next后执行该函数
   5. yield表达式只能出现在generator函数中，出现在其他地方会报错
   6. yield用在其他表达式内部时，需要使用小括号括起来；当yield用在函数参数/赋值表达式右侧时，可以不加括号
4. generator与iterator的联系：🧃
   1. 任何对象的`[Symbol.iterator]`方法，等于该对象的遍历器生成函数，调用该方法会返回一个遍历器对象；所以可以将generator函数赋给对象的该方法，之后该对象就可以被循环遍历了，比如for，`...`运算符等
   2. generator函数执行后，返回一个遍历器对象，该遍历器对象也有`[Symbol.iterator]`方法，执行后返回该对象本身

```js
// 🍅：yield表达式

// 若yield表达式出现在赋值表达式右侧，赋值左侧的变量值为undefined
function* ge () {
  return (yield 9)
}

// 结果：
const g = ge() // ge {<suspended>}
g.next()       // {value: 9, done: false}
g.next()       // {value: undefined, done: true}

// 🧃：让对象可遍历
const myObj = {}
myObj[Symbol.iterator] = function* () {
  yield Date.now()
  yield Date.now()
  yield Date.now()
}

[...myObj]    // [value1, value2, value3]
```

## next方法

1. yield表达式本身无返回值，或者说返回undefined
2. next方法可以带一个参数，该参数会当作上一个yield表达式的返回值：🧂
   1. 可以通过这个特性，给generator函数注入不同的值，然后改变函数的行为🍕
   2. 由于next方法的参数是作为上一个yield表达式的返回值，所以在第一次使用next方法时传参是无效的，V8引擎会忽略第一次next的参数；第一个next方法也可以说是来启用遍历器对象的（只有第一次调用next方法，才会执行generator内部的代码）
   3. 若想在第一次next时就将参数传入内部，需要再次嵌套一个函数🥝【当前未懂】

```js
// 🧂：yield表达式：
function* foo(x) {
  var y = 2 * (yield (x + 1));
  var z = yield (y / 3);
  return (x + y + z);
}

// 此时：得到：foo {<suspended>}
const f = foo(5)
// 此时：
// 1. 执行：yield (x + 1)，返回：{ value: 6, done: false }
f.next()
// 此时：
// 1. 执行：y = 2 * (yield (x + 1)), 由于next无参，故：y = 2 * undefined = NaN
// 2. 执行：yield (y / 3), 由于y = NaN，返回：{ value: NaN, done: false }
f.next()
// 此时：
// 1. 执行：z = yield(y / 3)，由于next无参，故：z = undefined
// 2. 执行：return (x + y + z)，即：return (5 + NaN + undefined), 返回：{ value: NaN, done: true }
f.next()

// 🍕：状态的暂停/恢复：无限运行的generator函数
function* status () {
  for (let i = 0; true; i++) {
    const reset = yield i
    if (reset) {
      i = -1
    }
  }
}

const s = status()
s.next()    // { value: 0, done: false }
s.next()    // { value: 1, done: false }
s.next()    // { value: 2, done: false }
s.next(3)   // { value: 0: done: false }

// 🥝：第一次就将参数传入生成函数中【未懂】
function wrapper(generatorFunction) {
  return function (...args) {
    let generatorObject = generatorFunction(...args);
    // 此处应该是先执行一次next，然后再执行就相当于将参数传入了
    generatorObject.next();
    return generatorObject;
  };
}

const wrapped = wrapper(function* () {
  console.log(`First input: ${yield}`);
  return 'DONE';
});

wrapped().next('hello!')
// First input: hello!
```

## for..of循环

1. for..of循环可以自动遍历Generator函数运行时生成的iterator对象，并且不再需要调用next方法：
2. 一旦next方法返回的对象done属性为true，该循环会被终止，且不包含该返回对象；即for..of循环只会遍历yield语句，不会遍历return
3. 利用for..of，结合generator，可以遍历任何对象的方法：🍎
4. for..of、扩展运算符(...)、解构赋值、Array.from调用的，都是遍历器接口，都可以将generator返回的对象作为参数

```js
// 🍎：遍历对象：for..of + generator
function* objectEntries(obj) {
  const propKeys = Reflect.ownKeys(obj)

  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]]
  }
}

const name = { firstName: 'jade', lastName: 'chou' }

// 第一种：遍历对象的键: [['firstName', 'jade'], ['lastName', 'chou']]
[...objectEntries(name)]

// 第二种：[['firstName', 'jade'], ['lastName', 'chou']]
name[Symbol.iterator] = objectEntries
[...name]
```

## Generator.prototype.throw()

1. generator返回的遍历器对象，都有一个throw方法：即在函数体外使用该方法抛出错误，然后在generator函数体内捕获错误（前提函数体内必须有try-catch，否则被外部的catch捕获/抛出异常）
2. throw方法接受一个参数（建议使用Error实例），该参数会被generator中的catch语句接收
3. throw方法抛出的错误要被内部的catch捕获，前提是必须执行一次next方法（第一次的next相当于启动执行generator内部的代码）
4. throw方法被内部catch捕获之后，会自动执行下一条yield语句（即自动执行一次next方法）
5. 当generator函数体内抛出错误时，若函数体内有catch，将被捕获，否则被外部的catch捕获，否则中断执行，抛出异常
6. 当generator函数体内抛出错误，且内部无catch语句，则该生成器函数不再执行；当再次调用next方法时，返回`{value: undefined, done: true}`