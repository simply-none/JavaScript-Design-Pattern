# 开放封闭原则

引入原因：需求变更过程中，为了满足新的需求去改动源代码，这个过程很难发现一些副作用（尤其是在一些逻辑多的函数中），可能会出现一系列的其他问题

定义：软件实体（对象、函数、类、实例等）应该是可以扩展增加的，但不可修改增加

思想：将变化的部分和稳定的部分（抽象出来的公共部分）隔离开来，然后把变化封装起来

应用场景：（几乎所有设计模式、设计原则都符合）

例子：
1. 使用对象多态性重构条件分支（条件分支：每增加/删除都需改动源代码）
2. 挂钩：在方法中有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向，使代码执行路径多一个分叉，预留多种可能（模板方法模式）
3. 回调函数：将变化的逻辑封装在回调函数中，把回调函数传入到一个稳定封闭的函数内（策略模式、命令模式）

开放封闭原则的相对性：
1. 参见附录
2. 挑出最容易发生变化的地方，然后构造抽象封闭这些变化
3. 若不可避免发生修改，尽量修改相对容易修改（操作相对简单）的地方

## 附录

1. 并不是时刻都要遵守原则，原则只是一个指导性的东西，实际开发中，需要在方便性和稳定性之间进行取舍
